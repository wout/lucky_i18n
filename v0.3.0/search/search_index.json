{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rosetta A blazing fast internationalization (i18n) library for Crystal with compile-time key lookup. You'll never have a missing translation in your app, ever again.","title":"Rosetta"},{"location":"#rosetta","text":"A blazing fast internationalization (i18n) library for Crystal with compile-time key lookup. You'll never have a missing translation in your app, ever again.","title":"Rosetta"},{"location":"configuration/","text":"Configuration Configuration options are defined as constants in your initializer file. Warning All configuration should happen before calling the Rosetta::Backend.load macro. DEFAULT_LOCALE Defines the default value if no locale is set. The default default locale is set to :en . Rosetta :: DEFAULT_LOCALE = \"es-ES\" The value can be either a String or a Symbol . Info The DEFAULT_LOCALE is used by the compiler to define the ruling set of locale keys. Which means that, if one of the other available locales is missing some of the keys found in the default key set, the compiler will complain. So every available locale will need to have the exact same key set as the default locale. AVAILABLE_LOCALES Defines all the available locales, including the default locale. The default for this setting is %i[en] . Rosetta :: AVAILABLE_LOCALES = %i[de en-GB en-US es nl] PLURALIZATION_RULES Defines a custom mapping of pluralization rules: Rosetta :: PLURALIZATION_RULES = { en : MyRule , nl : MyRule , } FALLBACKS TODO: Fallbacks still need to be implemented.","title":"Configuration"},{"location":"configuration/#configuration","text":"Configuration options are defined as constants in your initializer file. Warning All configuration should happen before calling the Rosetta::Backend.load macro.","title":"Configuration"},{"location":"configuration/#default_locale","text":"Defines the default value if no locale is set. The default default locale is set to :en . Rosetta :: DEFAULT_LOCALE = \"es-ES\" The value can be either a String or a Symbol . Info The DEFAULT_LOCALE is used by the compiler to define the ruling set of locale keys. Which means that, if one of the other available locales is missing some of the keys found in the default key set, the compiler will complain. So every available locale will need to have the exact same key set as the default locale.","title":"DEFAULT_LOCALE"},{"location":"configuration/#available_locales","text":"Defines all the available locales, including the default locale. The default for this setting is %i[en] . Rosetta :: AVAILABLE_LOCALES = %i[de en-GB en-US es nl]","title":"AVAILABLE_LOCALES"},{"location":"configuration/#pluralization_rules","text":"Defines a custom mapping of pluralization rules: Rosetta :: PLURALIZATION_RULES = { en : MyRule , nl : MyRule , }","title":"PLURALIZATION_RULES"},{"location":"configuration/#fallbacks","text":"TODO: Fallbacks still need to be implemented.","title":"FALLBACKS"},{"location":"getting_started/","text":"Installation 1. Add the dependency to your shard.yml : dependencies : rosetta : github : wout/rosetta 2. Run shards install 3. Run bin/rosetta --init Using Lucky Include rosetta in src/shards.cr : require \"rosetta\" Use the integrate macro in the config/rosetta.cr initializer to include Rosetta::Translatable in every base class where translations are needed: Rosetta :: Lucky . integrate Make sure your tranlations are in place: # config/rosetta/example.en.yml en : hello : show_page : welcome_message : \"Hi %{name}!\" Localize your app: class Hello:: ShowPage < MainLayout def content h1 r ( \".welcome_message\" ) . t ( name : \"Jeremy\" ) # => \"Hi Jeremy!\" end end Using Kemal Make sure your tranlations are in place: # config/rosetta/example.en.yml en : welcome_message : \"Hi %{name}!\" Then require \"config/rosetta\" and include Rosetta::Translatable , and you're good to go: require \"kemal\" require \"../config/rosetta\" include Rosetta :: Translatable get \"/\" do r ( \"welcome_message\" ) . t ( name : \"Serdar\" ) # => \"Hi Serdar!\" end Other frameworks First require \"config/rosetta.cr\" in your app, and include the Rosetta::Translatable mixin in the base class of controllers, models, views and anywhere else where you need Rosetta: require \"config/rosetta.cr\" abstract class BaseController include Rosetta :: Translatable end Make sure your tranlations are in place: # config/rosetta/example.en.yml en : hello_controller : welcome_message : \"Hi %{name}!\" Localize your app: class HelloController < BaseController def index puts r ( \".welcome_message\" ) . t ( name : \"Brian\" ) # => \"Hi Brian!\" end end","title":"Getting started"},{"location":"getting_started/#installation","text":"1. Add the dependency to your shard.yml : dependencies : rosetta : github : wout/rosetta 2. Run shards install 3. Run bin/rosetta --init","title":"Installation"},{"location":"getting_started/#using-lucky","text":"Include rosetta in src/shards.cr : require \"rosetta\" Use the integrate macro in the config/rosetta.cr initializer to include Rosetta::Translatable in every base class where translations are needed: Rosetta :: Lucky . integrate Make sure your tranlations are in place: # config/rosetta/example.en.yml en : hello : show_page : welcome_message : \"Hi %{name}!\" Localize your app: class Hello:: ShowPage < MainLayout def content h1 r ( \".welcome_message\" ) . t ( name : \"Jeremy\" ) # => \"Hi Jeremy!\" end end","title":"Using Lucky"},{"location":"getting_started/#using-kemal","text":"Make sure your tranlations are in place: # config/rosetta/example.en.yml en : welcome_message : \"Hi %{name}!\" Then require \"config/rosetta\" and include Rosetta::Translatable , and you're good to go: require \"kemal\" require \"../config/rosetta\" include Rosetta :: Translatable get \"/\" do r ( \"welcome_message\" ) . t ( name : \"Serdar\" ) # => \"Hi Serdar!\" end","title":"Using Kemal"},{"location":"getting_started/#other-frameworks","text":"First require \"config/rosetta.cr\" in your app, and include the Rosetta::Translatable mixin in the base class of controllers, models, views and anywhere else where you need Rosetta: require \"config/rosetta.cr\" abstract class BaseController include Rosetta :: Translatable end Make sure your tranlations are in place: # config/rosetta/example.en.yml en : hello_controller : welcome_message : \"Hi %{name}!\" Localize your app: class HelloController < BaseController def index puts r ( \".welcome_message\" ) . t ( name : \"Brian\" ) # => \"Hi Brian!\" end end","title":"Other frameworks"},{"location":"interpolation/","text":"Arguments and NamedTuple Interpolations can be passed as arguments for the t method: Rosetta . find ( \"user.welcome_message\" ) . t ( name : \"Ary\" ) # => \"Hi Ary!\" A NamedTuple works as well: Rosetta . find ( \"user.welcome_message\" ) . t ({ name : \"Ary\" }) # => \"Hi Ary!\" Important to know here is that translations with interpolation keys will always require you to call the t method with the right number of interpolation keys, or the compiler will complain: # en.user.welcome_message: \"Hi %{name}!\" Rosetta . find ( \"user.welcome_message\" ) . t Error : wrong number of arguments for ' Rosetta :: Locales :: User_WelcomeMessage #t' ( given 0 , expected 1 ) Overloads are : - Rosetta :: Locales :: User_WelcomeMessage #t(name : String) - Rosetta :: Locales :: User_WelcomeMessage #t(values : NamedTuple(name: String)) This is to ensure you're not missing any interpolation values. Time directives If the string in your locale files contains time format directives, Rosetta will require a time object as one of the interpolation arguments and translate the value to the current locale: # es.messages.great_day: \"\u00a1Hola %{name}, que tengas un buen %A!\" Rosetta . find ( \"messages.great_day\" ) . t ( name : \"Brian\" , time : Time . local ) # => \"\u00a1Hola Brian, que tengas un buen domingo!\" Working with a Hash The t method does not accept hashes, only arguments or a NamedTuple . For situations where you have to use a hash, there's the t_hash method: Rosetta . find ( \"user.welcome_message\" ) . t_hash ({ :name => \"Beta\" }) # => \"Hi Beta!\" Warning This method is considered unsafe because the content of hashes can't be checked at compile-time. It's also much slower, because interpolation values are inserted using gsub instead of native string interpolation. So, only use it when there's no other way, and use it with care. The uninterpolated string The raw, uninterpolated string, can be accessed with the raw method: Rosetta . find ( \"user.welcome_message\" ) . raw # => \"\u00a1Hola %{name}, que tengas un buen %A!\" Which can then be interpolated later: value = Rosetta . find ( \"messages.great_day\" ) . raw # => \"\u00a1Hola %{name}, que tengas un buen %A!\" Rosetta . interpolate ( value , { name : \"Ary\" , time : Time . local }) # => \"\u00a1Hola Ary, que tengas un buen domingo!\" Warning The Rosetta.interpolate method uses gsub rather than native string interpolation, so it's a lot slower and it doesn't check if all the required interpolation keys are given.","title":"Interpolation"},{"location":"interpolation/#arguments-and-namedtuple","text":"Interpolations can be passed as arguments for the t method: Rosetta . find ( \"user.welcome_message\" ) . t ( name : \"Ary\" ) # => \"Hi Ary!\" A NamedTuple works as well: Rosetta . find ( \"user.welcome_message\" ) . t ({ name : \"Ary\" }) # => \"Hi Ary!\" Important to know here is that translations with interpolation keys will always require you to call the t method with the right number of interpolation keys, or the compiler will complain: # en.user.welcome_message: \"Hi %{name}!\" Rosetta . find ( \"user.welcome_message\" ) . t Error : wrong number of arguments for ' Rosetta :: Locales :: User_WelcomeMessage #t' ( given 0 , expected 1 ) Overloads are : - Rosetta :: Locales :: User_WelcomeMessage #t(name : String) - Rosetta :: Locales :: User_WelcomeMessage #t(values : NamedTuple(name: String)) This is to ensure you're not missing any interpolation values.","title":"Arguments and NamedTuple"},{"location":"interpolation/#time-directives","text":"If the string in your locale files contains time format directives, Rosetta will require a time object as one of the interpolation arguments and translate the value to the current locale: # es.messages.great_day: \"\u00a1Hola %{name}, que tengas un buen %A!\" Rosetta . find ( \"messages.great_day\" ) . t ( name : \"Brian\" , time : Time . local ) # => \"\u00a1Hola Brian, que tengas un buen domingo!\"","title":"Time directives"},{"location":"interpolation/#working-with-a-hash","text":"The t method does not accept hashes, only arguments or a NamedTuple . For situations where you have to use a hash, there's the t_hash method: Rosetta . find ( \"user.welcome_message\" ) . t_hash ({ :name => \"Beta\" }) # => \"Hi Beta!\" Warning This method is considered unsafe because the content of hashes can't be checked at compile-time. It's also much slower, because interpolation values are inserted using gsub instead of native string interpolation. So, only use it when there's no other way, and use it with care.","title":"Working with a Hash"},{"location":"interpolation/#the-uninterpolated-string","text":"The raw, uninterpolated string, can be accessed with the raw method: Rosetta . find ( \"user.welcome_message\" ) . raw # => \"\u00a1Hola %{name}, que tengas un buen %A!\" Which can then be interpolated later: value = Rosetta . find ( \"messages.great_day\" ) . raw # => \"\u00a1Hola %{name}, que tengas un buen %A!\" Rosetta . interpolate ( value , { name : \"Ary\" , time : Time . local }) # => \"\u00a1Hola Ary, que tengas un buen domingo!\" Warning The Rosetta.interpolate method uses gsub rather than native string interpolation, so it's a lot slower and it doesn't check if all the required interpolation keys are given.","title":"The uninterpolated string"},{"location":"locale_files/","text":"Locale files en : example : translation : \"Hello world!\" interpolation : \"Hi %{name}, have a great %A!\" pluralization : one : \"One item\" other : \"%{count} items\" Chop up your locale files and place them in subdirectories. Use YAML or JSON files, or mix them together. Organise them any way you prefer. Warning Beware, though, that there is a fixed loading order. JSON files are loaded first, then YAML files. So in the unlikely situation where you have the same key in a JSON and a YAML file, YAML will take precedence.","title":"Locale files"},{"location":"locale_files/#locale-files","text":"en : example : translation : \"Hello world!\" interpolation : \"Hi %{name}, have a great %A!\" pluralization : one : \"One item\" other : \"%{count} items\" Chop up your locale files and place them in subdirectories. Use YAML or JSON files, or mix them together. Organise them any way you prefer. Warning Beware, though, that there is a fixed loading order. JSON files are loaded first, then YAML files. So in the unlikely situation where you have the same key in a JSON and a YAML file, YAML will take precedence.","title":"Locale files"},{"location":"localization/","text":"Predefined localization formats, day names and month names, live under the rosetta_localization namespace in the locale files. The initializer script will install the required files for you in order to be able to work with Rosetta. Localized time Similar to translations, localization formats are fetched at compile-time and localized at runtime. Rosetta . time . l ( Time . local ) # => \"Sun, 29 Aug 2021 18:30:57 +0200\" This will use the :default format to convert the given Time object. Another predefined format can be passed: Rosetta . time ( :short ) . l ( Time . local ) # => \"29 Aug 18:30\" For specific formats, a string can be passed as well: Rosetta . time ( \"%H:%M:%S\" ) . l ( Time . local ) # => \"18:30:57\" Localized date Rosetta . date . l ( Time . local ) # => \"2021-08-29\" Or with a date-formatted tuple: Rosetta . date . l ({ 1991 , 9 , 17 }) # => \"1991-09-17\" Similar to the time macro, a predefined format can be passed: Rosetta . date ( :long ) . l ( Time . local ) # => \"August 29, 2021\" Or a completely custom format: Rosetta . date ( \"%Y\" ) . l ( Time . local ) # => \"2021\" Localized number Number formats work the same as date and time formats. Rosetta . number . l ( 123_456.789 ) # => \"123,456.79\" With a specific predefined format: Rosetta . number ( :custom ) . l ( 123_456.789 ) # => \"12 34 56.789\" Or with specific formatting options: Rosetta . number . l ( 123_456.789 , decimal_places : 6 ) # => \"123,456.789000\" Info In the background, Rosetta uses Crystal's native Number#format method and accepts the same parameters. The Localizable mixin Include this mixin anywhere you want to work with localized dates, times and numbers. Here's an example of its usage: class User include Rosetta :: Localizable def birthday r_date ( :short ) . l ( born_at ) end end User . new . birthday # => \"Feb 20\" Similarly there are the r_time and the r_number macros for retrieval, returning a struct which accepts the l method for the value that needs to be localized.","title":"Date, time and numbers"},{"location":"localization/#localized-time","text":"Similar to translations, localization formats are fetched at compile-time and localized at runtime. Rosetta . time . l ( Time . local ) # => \"Sun, 29 Aug 2021 18:30:57 +0200\" This will use the :default format to convert the given Time object. Another predefined format can be passed: Rosetta . time ( :short ) . l ( Time . local ) # => \"29 Aug 18:30\" For specific formats, a string can be passed as well: Rosetta . time ( \"%H:%M:%S\" ) . l ( Time . local ) # => \"18:30:57\"","title":"Localized time"},{"location":"localization/#localized-date","text":"Rosetta . date . l ( Time . local ) # => \"2021-08-29\" Or with a date-formatted tuple: Rosetta . date . l ({ 1991 , 9 , 17 }) # => \"1991-09-17\" Similar to the time macro, a predefined format can be passed: Rosetta . date ( :long ) . l ( Time . local ) # => \"August 29, 2021\" Or a completely custom format: Rosetta . date ( \"%Y\" ) . l ( Time . local ) # => \"2021\"","title":"Localized date"},{"location":"localization/#localized-number","text":"Number formats work the same as date and time formats. Rosetta . number . l ( 123_456.789 ) # => \"123,456.79\" With a specific predefined format: Rosetta . number ( :custom ) . l ( 123_456.789 ) # => \"12 34 56.789\" Or with specific formatting options: Rosetta . number . l ( 123_456.789 , decimal_places : 6 ) # => \"123,456.789000\" Info In the background, Rosetta uses Crystal's native Number#format method and accepts the same parameters.","title":"Localized number"},{"location":"localization/#the-localizable-mixin","text":"Include this mixin anywhere you want to work with localized dates, times and numbers. Here's an example of its usage: class User include Rosetta :: Localizable def birthday r_date ( :short ) . l ( born_at ) end end User . new . birthday # => \"Feb 20\" Similarly there are the r_time and the r_number macros for retrieval, returning a struct which accepts the l method for the value that needs to be localized.","title":"The Localizable mixin"},{"location":"parser_checks/","text":"After loading all locales, the parser does a series of checkes on the given set. Check 1: presence of translations for all locales If the full set of translations is missing for a locale in the configured AVAILABLE_LOCALES , the parser will raise an error similar to the following: Error: Expected to find translations for : \u2023 en \u2023 nl \u2023 fr But missing all translations for : \u2023 fr Check 2: presence of ruling key set in all alternative locales The DEFAULT_LOCALE will define the key set that should be present in every alternative locale. If keys are missing, you'll get an error like the one below: Error: Missing keys for locale \"nl\" : \u2023 user.first_name \u2023 user.gender.male \u2023 user.gender.female \u2023 user.gender.non_binary Check 3: no additional keys in alternative locales If any of the alternative locales has keys that aren't present in the key set of the DEFAULT_LOCALE , the parser will raise an error: Error: The \"nl\" locale has unused keys: \u2023 user.name \u2023 user.date_of_birth Check 4: interpolation keys are present in every translation If a translation in the DEFAULT_LOCALE has one or more interpolation keys, then those interpolation keys should also be present in the alternative locales. If not, an error similar to the following will be raised: Error: Some translations have mismatching interpolation keys: \u2023 nl: message.welcome should contain \"%{first_name}\" \u2023 nl: base.validations.min_max should contain \"%{min}\" \u2023 nl: base.validations.min_max should contain \"%{max}\" \u2023 fr: message.welcome should contain \"%{first_name}\"","title":"Parser checks"},{"location":"parser_checks/#check-1-presence-of-translations-for-all-locales","text":"If the full set of translations is missing for a locale in the configured AVAILABLE_LOCALES , the parser will raise an error similar to the following: Error: Expected to find translations for : \u2023 en \u2023 nl \u2023 fr But missing all translations for : \u2023 fr","title":"Check 1: presence of translations for all locales"},{"location":"parser_checks/#check-2-presence-of-ruling-key-set-in-all-alternative-locales","text":"The DEFAULT_LOCALE will define the key set that should be present in every alternative locale. If keys are missing, you'll get an error like the one below: Error: Missing keys for locale \"nl\" : \u2023 user.first_name \u2023 user.gender.male \u2023 user.gender.female \u2023 user.gender.non_binary","title":"Check 2: presence of ruling key set in all alternative locales"},{"location":"parser_checks/#check-3-no-additional-keys-in-alternative-locales","text":"If any of the alternative locales has keys that aren't present in the key set of the DEFAULT_LOCALE , the parser will raise an error: Error: The \"nl\" locale has unused keys: \u2023 user.name \u2023 user.date_of_birth","title":"Check 3: no additional keys in alternative locales"},{"location":"parser_checks/#check-4-interpolation-keys-are-present-in-every-translation","text":"If a translation in the DEFAULT_LOCALE has one or more interpolation keys, then those interpolation keys should also be present in the alternative locales. If not, an error similar to the following will be raised: Error: Some translations have mismatching interpolation keys: \u2023 nl: message.welcome should contain \"%{first_name}\" \u2023 nl: base.validations.min_max should contain \"%{min}\" \u2023 nl: base.validations.min_max should contain \"%{max}\" \u2023 fr: message.welcome should contain \"%{first_name}\"","title":"Check 4: interpolation keys are present in every translation"},{"location":"pluralization/","text":"Pluralizable locales A pluralization in the locale files may look like the one below: en : example : pluralization : one : \"One item\" other : \"%{count} items\" The parser will interpret a translation as a pluralizable one if it contains a key called other , and its value contains a %{count} interpolation key. Category tags All the short category tags defined by the CLDR are supported: zero one (singular) two (dual) few (paucal) many (also used for fractions if they have a separate class) other (required\u2014general plural form\u2014also used if the language only has a single form) Pluralizable translations For pluralizable translations, the t method will require the count argument, which can be a Float or an Int : Rosetta . find ( \"example.pluralization\" ) . t ( count : 1 ) # => \"One item\" Rosetta . find ( \"example.pluralization\" ) . t ( count : 12 ) # => \"12 items\" Pluralization rules Rosetta includes pluralization rules for most of the available locales. They can ba found in the repo under src/rosetta/pluralization/rule . Custom pluralization rules Custom rules need to inherit from Rosetta::Pluralization::Rule , define the apply method and define the required CategoryTags annotation. For example: @[ CategoryTags ( :zero , :one , :other ) ] struct MyRule < Rosette :: Pluralization :: Rule def apply ( count : Float | Int ) : Symbol case count when 0 :zero when 1 :one else :other end end end Info The CategoryTags annotation is used by the parser to check if the required category tags are all present in the pluralizable translations. If the annotation is not defined, the compiler will let you know. In the initializer Rosetta created at setup, register the rule for one or more locales: Rosetta :: PLURALIZATION_RULES = { en : MyRule , nl : MyRule , } Warning Configuring custom rules should happen before calling the Rosetta::Backend.load macro.","title":"Pluralization"},{"location":"pluralization/#pluralizable-locales","text":"A pluralization in the locale files may look like the one below: en : example : pluralization : one : \"One item\" other : \"%{count} items\" The parser will interpret a translation as a pluralizable one if it contains a key called other , and its value contains a %{count} interpolation key.","title":"Pluralizable locales"},{"location":"pluralization/#category-tags","text":"All the short category tags defined by the CLDR are supported: zero one (singular) two (dual) few (paucal) many (also used for fractions if they have a separate class) other (required\u2014general plural form\u2014also used if the language only has a single form)","title":"Category tags"},{"location":"pluralization/#pluralizable-translations","text":"For pluralizable translations, the t method will require the count argument, which can be a Float or an Int : Rosetta . find ( \"example.pluralization\" ) . t ( count : 1 ) # => \"One item\" Rosetta . find ( \"example.pluralization\" ) . t ( count : 12 ) # => \"12 items\"","title":"Pluralizable translations"},{"location":"pluralization/#pluralization-rules","text":"Rosetta includes pluralization rules for most of the available locales. They can ba found in the repo under src/rosetta/pluralization/rule .","title":"Pluralization rules"},{"location":"pluralization/#custom-pluralization-rules","text":"Custom rules need to inherit from Rosetta::Pluralization::Rule , define the apply method and define the required CategoryTags annotation. For example: @[ CategoryTags ( :zero , :one , :other ) ] struct MyRule < Rosette :: Pluralization :: Rule def apply ( count : Float | Int ) : Symbol case count when 0 :zero when 1 :one else :other end end end Info The CategoryTags annotation is used by the parser to check if the required category tags are all present in the pluralizable translations. If the annotation is not defined, the compiler will let you know. In the initializer Rosetta created at setup, register the rule for one or more locales: Rosetta :: PLURALIZATION_RULES = { en : MyRule , nl : MyRule , } Warning Configuring custom rules should happen before calling the Rosetta::Backend.load macro.","title":"Custom pluralization rules"},{"location":"set_the_current_locale/","text":"Globally If no value is set, the value of the Rosetta.default_locale macro will be used. This macro will first look if Rosetta::DEFAULT_LOCALE is defined, and if it is not, it will fall back to an internal value ( :en ). Defining the current locale is done as folows: Rosetta . locale = :es This property accepts a String or a Symbol . But note that the getter variant of this property will always return a string: Rosetta . locale = :nl Rosetta . locale # => \"nl\" If the given locale identifier is not present in the array returned by the Rosetta.available_locales macro, the value of the Rosetta.default_locale macro will be used instead: Rosetta :: DEFAULT_LOCALE = :es Rosetta . locale = :xx Roestta . locale # => \"es\" Locally Sometimes you'll want to use a different locale for a specific part of your code. In that case, use the Rosetta.with_locale method: Rosetta . find ( \"user.first_name\" ) . t # => First name Rosetta . with_locale ( :nl ) do Rosetta . find ( \"user.first_name\" ) . t # => \"Voornaam\" end Rosetta . find ( \"user.first_name\" ) . t # => First name","title":"Set the current locale"},{"location":"set_the_current_locale/#globally","text":"If no value is set, the value of the Rosetta.default_locale macro will be used. This macro will first look if Rosetta::DEFAULT_LOCALE is defined, and if it is not, it will fall back to an internal value ( :en ). Defining the current locale is done as folows: Rosetta . locale = :es This property accepts a String or a Symbol . But note that the getter variant of this property will always return a string: Rosetta . locale = :nl Rosetta . locale # => \"nl\" If the given locale identifier is not present in the array returned by the Rosetta.available_locales macro, the value of the Rosetta.default_locale macro will be used instead: Rosetta :: DEFAULT_LOCALE = :es Rosetta . locale = :xx Roestta . locale # => \"es\"","title":"Globally"},{"location":"set_the_current_locale/#locally","text":"Sometimes you'll want to use a different locale for a specific part of your code. In that case, use the Rosetta.with_locale method: Rosetta . find ( \"user.first_name\" ) . t # => First name Rosetta . with_locale ( :nl ) do Rosetta . find ( \"user.first_name\" ) . t # => \"Voornaam\" end Rosetta . find ( \"user.first_name\" ) . t # => First name","title":"Locally"},{"location":"setup/","text":"Setup The bin/rosetta --init command will generate the initial files to get started. 1. An initializer with the following content: # config/rosetta.cr require \"rosetta\" Rosetta :: DEFAULT_LOCALE = :en Rosetta :: AVAILABLE_LOCALES = %i[en] Rosetta :: Backend . load ( \"config/rosetta\" ) 2. config/rosetta/rosetta.en.yml This file contains localiztions required by Rosetta. For every additional locale, you'll need to copy and translate this file. In the future, files for many languages will be included. Please consider contributing your translations. 3. config/locales/example.en.yml An example locale file, which you can modify or delete.","title":"Setup"},{"location":"setup/#setup","text":"The bin/rosetta --init command will generate the initial files to get started. 1. An initializer with the following content: # config/rosetta.cr require \"rosetta\" Rosetta :: DEFAULT_LOCALE = :en Rosetta :: AVAILABLE_LOCALES = %i[en] Rosetta :: Backend . load ( \"config/rosetta\" ) 2. config/rosetta/rosetta.en.yml This file contains localiztions required by Rosetta. For every additional locale, you'll need to copy and translate this file. In the future, files for many languages will be included. Please consider contributing your translations. 3. config/locales/example.en.yml An example locale file, which you can modify or delete.","title":"Setup"},{"location":"translations/","text":"Lookup Looking up translations is done with the find macro: Rosetta . find ( \"user.name\" ) This will return a struct containing all the translation data for the given key. To get the translation for the currently selected locale, call the t method: Rosetta . find ( \"user.name\" ) . t # => \"User name\" Optionally, you can call to_s or use the struct with string interpolation: Rosetta . find ( \"user.name\" ) . to_s # => \"User name\" \" #{ Rosetta . find ( \"user.name\" ) } \" # => \"User name\" The translation struct also includes the Lucky::AllowedInTags module, so it works with Lucky templates as well, even without having to call t : class Products:: ShowPage < MainLayout def content h1 Rosetta . find ( \".heading\" ) end end Getting all translations When required, the translations for all locales can be accessed with the translations property: Rosetta . find ( \"user.first_name\" ) . translations # => {en: \"First name\", nl: \"Voornaam\"} The Translatable mixin This mixin makes it more convenient to work with translated values in your classes. Here's an example of its usage: Rosetta . locale = :es class User include Rosetta :: Translatable def name_label r ( \"user.name_label\" ) . t end end User . new . name_label # => \"Nombre\" The r macro essentially is an alias for the Rosetta.find macro, but it introduces the possibility to use inferred locale keys. By omitting the prefix of the locale key and having the key start with a . , the key prefix will be derived from the current class name: class User include Rosetta :: Translatable def name_label r ( \".name_label\" ) . t # => resolves to \"user.name_label\" end end This also works with nested class names, for example: User => \"user\" Components::MainMenu => \"components.main_menu\" Helpers::SiteSections::UserSettings => \"helpers.site_sections.user_settings\" Using inferred locale keys has an added bonus. You don't need to think about how to organise your locale files. And it also makes finding your keys a lot easier. Finally, in case you want to use another prefix for the current class, a constant can be used: class User include Rosetta :: Translatable ROSETTA_PREFIX = \"guest\" def name_label r ( \".name_label\" ) . t # => resolves to \"guest.name_label\" end end Just like the global Rosetta.find marco, interpolations are passed using the t method: class User include Rosetta :: Translatable def welcome_message r ( \".welcome_message\" ) . t ( name : \"Ary\" ) end end The r macro uses Rosetta.find to get the translations for a given key at compile-time. Then the t method translates the value at runtime.","title":"Translations"},{"location":"translations/#lookup","text":"Looking up translations is done with the find macro: Rosetta . find ( \"user.name\" ) This will return a struct containing all the translation data for the given key. To get the translation for the currently selected locale, call the t method: Rosetta . find ( \"user.name\" ) . t # => \"User name\" Optionally, you can call to_s or use the struct with string interpolation: Rosetta . find ( \"user.name\" ) . to_s # => \"User name\" \" #{ Rosetta . find ( \"user.name\" ) } \" # => \"User name\" The translation struct also includes the Lucky::AllowedInTags module, so it works with Lucky templates as well, even without having to call t : class Products:: ShowPage < MainLayout def content h1 Rosetta . find ( \".heading\" ) end end","title":"Lookup"},{"location":"translations/#getting-all-translations","text":"When required, the translations for all locales can be accessed with the translations property: Rosetta . find ( \"user.first_name\" ) . translations # => {en: \"First name\", nl: \"Voornaam\"}","title":"Getting all translations"},{"location":"translations/#the-translatable-mixin","text":"This mixin makes it more convenient to work with translated values in your classes. Here's an example of its usage: Rosetta . locale = :es class User include Rosetta :: Translatable def name_label r ( \"user.name_label\" ) . t end end User . new . name_label # => \"Nombre\" The r macro essentially is an alias for the Rosetta.find macro, but it introduces the possibility to use inferred locale keys. By omitting the prefix of the locale key and having the key start with a . , the key prefix will be derived from the current class name: class User include Rosetta :: Translatable def name_label r ( \".name_label\" ) . t # => resolves to \"user.name_label\" end end This also works with nested class names, for example: User => \"user\" Components::MainMenu => \"components.main_menu\" Helpers::SiteSections::UserSettings => \"helpers.site_sections.user_settings\" Using inferred locale keys has an added bonus. You don't need to think about how to organise your locale files. And it also makes finding your keys a lot easier. Finally, in case you want to use another prefix for the current class, a constant can be used: class User include Rosetta :: Translatable ROSETTA_PREFIX = \"guest\" def name_label r ( \".name_label\" ) . t # => resolves to \"guest.name_label\" end end Just like the global Rosetta.find marco, interpolations are passed using the t method: class User include Rosetta :: Translatable def welcome_message r ( \".welcome_message\" ) . t ( name : \"Ary\" ) end end The r macro uses Rosetta.find to get the translations for a given key at compile-time. Then the t method translates the value at runtime.","title":"The Translatable mixin"},{"location":"why_rosetta/","text":"Why use Rosetta? You'll never have a missing translation Rosetta is different from other internationalization libraries because it handles key lookup at compile-time rather than runtime. The significant advantage is that you'll be able to find missing translations - or typos in your locale keys - during development rather than after you've deployed your app. This is also true for translation keys in all additional locales. You'll never have a missing interpolation In Rosetta, interpolation keys are arguments to the translation method. So if you're missing an argument, the compiler will complain. The parser will also compare interpolation keys in additional locales to the ones found in the default locale, and let you know if some are missing. Rosetta is 10x faster than similar libraries Benchmarking against other libraries which also use YAML or JSON backends, Rosetta is about 10x faster than any other one. For simple translations: i18n.cr translation 147.72k ( 6.77\u00b5s) (\u00b1 3.36%) 0.99kB/op 178.77\u00d7 slower i18n translation 2.25M (443.68ns) (\u00b1 3.44%) 48.0B/op 11.05\u00d7 slower lens translation 1.10M (912.67ns) (\u00b1 7.10%) 176B/op 22.72\u00d7 slower rosetta translation 24.89M ( 40.17ns) (\u00b1 6.59%) 0.0B/op fastest For translations with interpolations: i18n.cr interpolation 145.50k ( 6.87\u00b5s) (\u00b1 4.47%) 0.99kB/op 23.12\u00d7 slower i18n interpolation 138.84k ( 7.20\u00b5s) (\u00b1 4.16%) 2.05kB/op 21.23\u00d7 slower lens interpolation 314.68k ( 3.18\u00b5s) (\u00b1 7.30%) 561B/op 9.29\u00d7 slower rosetta interpolation 2.95M (339.26ns) (\u00b1 7.17%) 80.0B/op fastest Rosetta is that much faster because a lot of the hard work happens at compile-time, and the majority of the data is stored on the stack rather than the heap , out of the scope of garbage collector. Info Libraries used in benchmarks are crimson-knight/i18n.cr , crystal-i18n/i18n and syeopite/lens .","title":"Why Rosetta?"},{"location":"why_rosetta/#why-use-rosetta","text":"","title":"Why use Rosetta?"},{"location":"why_rosetta/#youll-never-have-a-missing-translation","text":"Rosetta is different from other internationalization libraries because it handles key lookup at compile-time rather than runtime. The significant advantage is that you'll be able to find missing translations - or typos in your locale keys - during development rather than after you've deployed your app. This is also true for translation keys in all additional locales.","title":"You'll never have a missing translation"},{"location":"why_rosetta/#youll-never-have-a-missing-interpolation","text":"In Rosetta, interpolation keys are arguments to the translation method. So if you're missing an argument, the compiler will complain. The parser will also compare interpolation keys in additional locales to the ones found in the default locale, and let you know if some are missing.","title":"You'll never have a missing interpolation"},{"location":"why_rosetta/#rosetta-is-10x-faster-than-similar-libraries","text":"Benchmarking against other libraries which also use YAML or JSON backends, Rosetta is about 10x faster than any other one. For simple translations: i18n.cr translation 147.72k ( 6.77\u00b5s) (\u00b1 3.36%) 0.99kB/op 178.77\u00d7 slower i18n translation 2.25M (443.68ns) (\u00b1 3.44%) 48.0B/op 11.05\u00d7 slower lens translation 1.10M (912.67ns) (\u00b1 7.10%) 176B/op 22.72\u00d7 slower rosetta translation 24.89M ( 40.17ns) (\u00b1 6.59%) 0.0B/op fastest For translations with interpolations: i18n.cr interpolation 145.50k ( 6.87\u00b5s) (\u00b1 4.47%) 0.99kB/op 23.12\u00d7 slower i18n interpolation 138.84k ( 7.20\u00b5s) (\u00b1 4.16%) 2.05kB/op 21.23\u00d7 slower lens interpolation 314.68k ( 3.18\u00b5s) (\u00b1 7.30%) 561B/op 9.29\u00d7 slower rosetta interpolation 2.95M (339.26ns) (\u00b1 7.17%) 80.0B/op fastest Rosetta is that much faster because a lot of the hard work happens at compile-time, and the majority of the data is stored on the stack rather than the heap , out of the scope of garbage collector. Info Libraries used in benchmarks are crimson-knight/i18n.cr , crystal-i18n/i18n and syeopite/lens .","title":"Rosetta is 10x faster than similar libraries"}]}