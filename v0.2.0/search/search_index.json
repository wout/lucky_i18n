{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rosetta A blazing fast internationalization (i18n) library for Crystal with compile-time key lookup. You'll never have a missing translation in your app, ever again.","title":"Rosetta"},{"location":"#rosetta","text":"A blazing fast internationalization (i18n) library for Crystal with compile-time key lookup. You'll never have a missing translation in your app, ever again.","title":"Rosetta"},{"location":"configuration/","text":"Configuration Configuration options are defined as constants in your initializer file. DEFAULT_LOCALE Defines the default value if no locale is set. The default default locale is set to :en . Rosetta :: DEFAULT_LOCALE = \"es-ES\" The value can be either a String or a Symbol . Info The DEFAULT_LOCALE is used by the compiler to define the ruling set of locale keys. Which means that, if one of the other available locales is missing some of the keys found in the default key set, the compiler will complain. So every available locale will need to have the exact same key set as the default locale. AVAILABLE_LOCALES Defines all the available locales, including the default locale. The default for this setting is %i[en] . Rosetta :: AVAILABLE_LOCALES = %i[de en-GB en-US es nl] FALLBACKS TODO: Fallbacks still need to be implemented.","title":"Configuration"},{"location":"configuration/#configuration","text":"Configuration options are defined as constants in your initializer file.","title":"Configuration"},{"location":"configuration/#default_locale","text":"Defines the default value if no locale is set. The default default locale is set to :en . Rosetta :: DEFAULT_LOCALE = \"es-ES\" The value can be either a String or a Symbol . Info The DEFAULT_LOCALE is used by the compiler to define the ruling set of locale keys. Which means that, if one of the other available locales is missing some of the keys found in the default key set, the compiler will complain. So every available locale will need to have the exact same key set as the default locale.","title":"DEFAULT_LOCALE"},{"location":"configuration/#available_locales","text":"Defines all the available locales, including the default locale. The default for this setting is %i[en] . Rosetta :: AVAILABLE_LOCALES = %i[de en-GB en-US es nl]","title":"AVAILABLE_LOCALES"},{"location":"configuration/#fallbacks","text":"TODO: Fallbacks still need to be implemented.","title":"FALLBACKS"},{"location":"getting_started/","text":"Installation 1. Add the dependency to your shard.yml : dependencies : rosetta : github : wout/rosetta 2. Run shards install 3. Run bin/rosetta --init 4. Require the shard (optional) # src/shards.cr require \"rosetta\" 5. Include the Rosetta::Translatable mixin # e.g. src/pages/main_layout.cr include Rosetta :: Translatable 6. Localize your app Rosetta . locale = :es class Hello:: ShowPage < MainLayout def content h1 r ( \"welcome_message\" ) . t ( name : \"Brian\" ) # => \"\u00a1Hola Brian!\" end end","title":"Getting started"},{"location":"getting_started/#installation","text":"","title":"Installation"},{"location":"getting_started/#1-add-the-dependency-to-your-shardyml","text":"dependencies : rosetta : github : wout/rosetta","title":"1. Add the dependency to your shard.yml:"},{"location":"getting_started/#2-run-shards-install","text":"","title":"2. Run shards install"},{"location":"getting_started/#3-run-binrosetta-init","text":"","title":"3. Run bin/rosetta --init"},{"location":"getting_started/#4-require-the-shard-optional","text":"# src/shards.cr require \"rosetta\"","title":"4. Require the shard (optional)"},{"location":"getting_started/#5-include-the-rosettatranslatable-mixin","text":"# e.g. src/pages/main_layout.cr include Rosetta :: Translatable","title":"5. Include the Rosetta::Translatable mixin"},{"location":"getting_started/#6-localize-your-app","text":"Rosetta . locale = :es class Hello:: ShowPage < MainLayout def content h1 r ( \"welcome_message\" ) . t ( name : \"Brian\" ) # => \"\u00a1Hola Brian!\" end end","title":"6. Localize your app"},{"location":"interpolations/","text":"Arguments and NamedTuple Interpolations can be passed as arguments for the t method: Rosetta . find ( \"user.welcome_message\" ) . t ( name : \"Ary\" ) # => \"Hi Ary!\" A NamedTuple works as well: Rosetta . find ( \"user.welcome_message\" ) . t ({ name : \"Ary\" }) # => \"Hi Ary!\" Important to know here is that translations with interpolation keys will always require you to call the t method with the right number of interpolation keys, or the compiler will complain: # en.user.welcome_message: \"Hi %{name}!\" Rosetta . find ( \"user.welcome_message\" ) . t Error : wrong number of arguments for ' Rosetta :: Locales :: User_WelcomeMessage #t' ( given 0 , expected 1 ) Overloads are : - Rosetta :: Locales :: User_WelcomeMessage #t(name : String) - Rosetta :: Locales :: User_WelcomeMessage #t(values : NamedTuple(name: String)) This is to ensure you're not missing any interpolation values. Time directives If the string in your locale files contains time format directives, Rosetta will require a time object as one of the interpolation arguments and translate the value to the current locale: # es.messages.great_day: \"\u00a1Hola %{name}, que tengas un buen %A!\" Rosetta . find ( \"messages.great_day\" ) . t ( name : \"Brian\" , time : Time . local ) # => \"\u00a1Hola Brian, que tengas un buen domingo!\" Working with a Hash The t method does not accept hashes, only arguments or a NamedTuple . For situations where you have to use a hash, there's the t_hash method: Rosetta . find ( \"user.welcome_message\" ) . t_hash ({ :name => \"Beta\" }) # => \"Hi Beta!\" Warning This method is considered unsafe because the content of hashes can't be checked at compile-time. It's also much slower, because interpolation values are inserted using gsub instead of native string interpolation. So, only use it when there's no other way, and use it with care. The uninterpolated string The raw, uninterpolated string, can be accessed with the raw method: Rosetta . find ( \"user.welcome_message\" ) . raw # => \"\u00a1Hola %{name}, que tengas un buen %A!\" Which can then be interpolated later: value = Rosetta . find ( \"messages.great_day\" ) . raw # => \"\u00a1Hola %{name}, que tengas un buen %A!\" Rosetta . interpolate ( value , { name : \"Ary\" , time : Time . local }) # => \"\u00a1Hola Ary, que tengas un buen domingo!\" Warning The Rosetta.interpolate method uses gsub rather than native string interpolation, so it's a lot slower and it doesn't check if all the required interpolation keys are given.","title":"Interpolations"},{"location":"interpolations/#arguments-and-namedtuple","text":"Interpolations can be passed as arguments for the t method: Rosetta . find ( \"user.welcome_message\" ) . t ( name : \"Ary\" ) # => \"Hi Ary!\" A NamedTuple works as well: Rosetta . find ( \"user.welcome_message\" ) . t ({ name : \"Ary\" }) # => \"Hi Ary!\" Important to know here is that translations with interpolation keys will always require you to call the t method with the right number of interpolation keys, or the compiler will complain: # en.user.welcome_message: \"Hi %{name}!\" Rosetta . find ( \"user.welcome_message\" ) . t Error : wrong number of arguments for ' Rosetta :: Locales :: User_WelcomeMessage #t' ( given 0 , expected 1 ) Overloads are : - Rosetta :: Locales :: User_WelcomeMessage #t(name : String) - Rosetta :: Locales :: User_WelcomeMessage #t(values : NamedTuple(name: String)) This is to ensure you're not missing any interpolation values.","title":"Arguments and NamedTuple"},{"location":"interpolations/#time-directives","text":"If the string in your locale files contains time format directives, Rosetta will require a time object as one of the interpolation arguments and translate the value to the current locale: # es.messages.great_day: \"\u00a1Hola %{name}, que tengas un buen %A!\" Rosetta . find ( \"messages.great_day\" ) . t ( name : \"Brian\" , time : Time . local ) # => \"\u00a1Hola Brian, que tengas un buen domingo!\"","title":"Time directives"},{"location":"interpolations/#working-with-a-hash","text":"The t method does not accept hashes, only arguments or a NamedTuple . For situations where you have to use a hash, there's the t_hash method: Rosetta . find ( \"user.welcome_message\" ) . t_hash ({ :name => \"Beta\" }) # => \"Hi Beta!\" Warning This method is considered unsafe because the content of hashes can't be checked at compile-time. It's also much slower, because interpolation values are inserted using gsub instead of native string interpolation. So, only use it when there's no other way, and use it with care.","title":"Working with a Hash"},{"location":"interpolations/#the-uninterpolated-string","text":"The raw, uninterpolated string, can be accessed with the raw method: Rosetta . find ( \"user.welcome_message\" ) . raw # => \"\u00a1Hola %{name}, que tengas un buen %A!\" Which can then be interpolated later: value = Rosetta . find ( \"messages.great_day\" ) . raw # => \"\u00a1Hola %{name}, que tengas un buen %A!\" Rosetta . interpolate ( value , { name : \"Ary\" , time : Time . local }) # => \"\u00a1Hola Ary, que tengas un buen domingo!\" Warning The Rosetta.interpolate method uses gsub rather than native string interpolation, so it's a lot slower and it doesn't check if all the required interpolation keys are given.","title":"The uninterpolated string"},{"location":"locale_files/","text":"Locale files en : example : translation : \"Hello world!\" interpolation : \"Hi %{name}, have a great %A!\" pluralization : one : \"One item\" other : \"%{count} items\" Chop up your locale files and place them in subdirectories. Use YAML or JSON files, or mix them together. Organise them any way you prefer. Warning Beware, though, that there is a fixed loading order. JSON files are loaded first, then YAML files. So in the unlikely situation where you have the same key in a JSON and a YAML file, YAML will take precedence.","title":"Locale files"},{"location":"locale_files/#locale-files","text":"en : example : translation : \"Hello world!\" interpolation : \"Hi %{name}, have a great %A!\" pluralization : one : \"One item\" other : \"%{count} items\" Chop up your locale files and place them in subdirectories. Use YAML or JSON files, or mix them together. Organise them any way you prefer. Warning Beware, though, that there is a fixed loading order. JSON files are loaded first, then YAML files. So in the unlikely situation where you have the same key in a JSON and a YAML file, YAML will take precedence.","title":"Locale files"},{"location":"localization/","text":"Predefined localization formats, day names and month names, live under the rosetta_localization namespace in the locale files. The initializer script will install the required files for you in order to be able to work with Rosetta. Localized time Similar to translations, localization formats are fetched at compile-time and localized at runtime. Rosetta . time . l ( Time . local ) # => \"Sun, 29 Aug 2021 18:30:57 +0200\" This will use the :default format to convert the given Time object. Another predefined format can be passed: Rosetta . time ( :short ) . l ( Time . local ) # => \"29 Aug 18:30\" For specific formats, a string can be passed as well: Rosetta . time ( \"%H:%M:%S\" ) . l ( Time . local ) # => \"18:30:57\" Localized date Rosetta . date . l ( Time . local ) # => \"2021-08-29\" Or with a date-formatted tuple: Rosetta . date . l ({ 1991 , 9 , 17 }) # => \"1991-09-17\" Similar to the time macro, a predefined format can be passed: Rosetta . date ( :long ) . l ( Time . local ) # => \"August 29, 2021\" Or a completely custom format: Rosetta . date ( \"%Y\" ) . l ( Time . local ) # => \"2021\" Localized number Number formats work the same as date and time formats. Rosetta . number . l ( 123_456.789 ) # => \"123,456.79\" With a specific predefined format: Rosetta . number ( :custom ) . l ( 123_456.789 ) # => \"12 34 56.789\" Or with specific formatting options: Rosetta . number . l ( 123_456.789 , decimal_places : 6 ) # => \"123,456.789000\" Info In the background, Rosetta uses Crystal's native Number#format method and accepts the same parameters. The Localizable mixin Include this mixin anywhere you want to work with localized dates, times and numbers. Here's an example of its usage: class User include Rosetta :: Localizable def birthday r_date ( :short ) . l ( born_at ) end end User . new . birthday # => \"Feb 20\" Similarly there are the r_time and the r_number macros for retrieval, returning a struct which accepts the l method for the value that needs to be localized.","title":"Date, time and numbers"},{"location":"localization/#localized-time","text":"Similar to translations, localization formats are fetched at compile-time and localized at runtime. Rosetta . time . l ( Time . local ) # => \"Sun, 29 Aug 2021 18:30:57 +0200\" This will use the :default format to convert the given Time object. Another predefined format can be passed: Rosetta . time ( :short ) . l ( Time . local ) # => \"29 Aug 18:30\" For specific formats, a string can be passed as well: Rosetta . time ( \"%H:%M:%S\" ) . l ( Time . local ) # => \"18:30:57\"","title":"Localized time"},{"location":"localization/#localized-date","text":"Rosetta . date . l ( Time . local ) # => \"2021-08-29\" Or with a date-formatted tuple: Rosetta . date . l ({ 1991 , 9 , 17 }) # => \"1991-09-17\" Similar to the time macro, a predefined format can be passed: Rosetta . date ( :long ) . l ( Time . local ) # => \"August 29, 2021\" Or a completely custom format: Rosetta . date ( \"%Y\" ) . l ( Time . local ) # => \"2021\"","title":"Localized date"},{"location":"localization/#localized-number","text":"Number formats work the same as date and time formats. Rosetta . number . l ( 123_456.789 ) # => \"123,456.79\" With a specific predefined format: Rosetta . number ( :custom ) . l ( 123_456.789 ) # => \"12 34 56.789\" Or with specific formatting options: Rosetta . number . l ( 123_456.789 , decimal_places : 6 ) # => \"123,456.789000\" Info In the background, Rosetta uses Crystal's native Number#format method and accepts the same parameters.","title":"Localized number"},{"location":"localization/#the-localizable-mixin","text":"Include this mixin anywhere you want to work with localized dates, times and numbers. Here's an example of its usage: class User include Rosetta :: Localizable def birthday r_date ( :short ) . l ( born_at ) end end User . new . birthday # => \"Feb 20\" Similarly there are the r_time and the r_number macros for retrieval, returning a struct which accepts the l method for the value that needs to be localized.","title":"The Localizable mixin"},{"location":"parser_checks/","text":"After loading all locales, the parser does a series of checkes on the given set. Check 1: presence of translations for all locales If the full set of translations is missing for a locale in the configured AVAILABLE_LOCALES , the parser will raise an error similar to the following: Error: Expected to find translations for : \u2023 en \u2023 nl \u2023 fr But missing all translations for : \u2023 fr Check 2: presence of ruling key set in all alternative locales The DEFAULT_LOCALE will define the key set that should be present in every alternative locale. If keys are missing, you'll get an error like the one below: Error: Missing keys for locale \"nl\" : \u2023 user.first_name \u2023 user.gender.male \u2023 user.gender.female \u2023 user.gender.non_binary Check 3: no additional keys in alternative locales If any of the alternative locales has keys that aren't present in the key set of the DEFAULT_LOCALE , the parser will raise an error: Error: The \"nl\" locale has unused keys: \u2023 user.name \u2023 user.date_of_birth Check 4: interpolation keys are present in every translation If a translation in the DEFAULT_LOCALE has one or more interpolation keys, then those interpolation keys should also be present in the alternative locales. If not, an error similar to the following will be raised: Error: Some translations have mismatching interpolation keys: \u2023 nl: message.welcome should contain \"%{first_name}\" \u2023 nl: base.validations.min_max should contain \"%{min}\" \u2023 nl: base.validations.min_max should contain \"%{max}\" \u2023 fr: message.welcome should contain \"%{first_name}\"","title":"Parser checks"},{"location":"parser_checks/#check-1-presence-of-translations-for-all-locales","text":"If the full set of translations is missing for a locale in the configured AVAILABLE_LOCALES , the parser will raise an error similar to the following: Error: Expected to find translations for : \u2023 en \u2023 nl \u2023 fr But missing all translations for : \u2023 fr","title":"Check 1: presence of translations for all locales"},{"location":"parser_checks/#check-2-presence-of-ruling-key-set-in-all-alternative-locales","text":"The DEFAULT_LOCALE will define the key set that should be present in every alternative locale. If keys are missing, you'll get an error like the one below: Error: Missing keys for locale \"nl\" : \u2023 user.first_name \u2023 user.gender.male \u2023 user.gender.female \u2023 user.gender.non_binary","title":"Check 2: presence of ruling key set in all alternative locales"},{"location":"parser_checks/#check-3-no-additional-keys-in-alternative-locales","text":"If any of the alternative locales has keys that aren't present in the key set of the DEFAULT_LOCALE , the parser will raise an error: Error: The \"nl\" locale has unused keys: \u2023 user.name \u2023 user.date_of_birth","title":"Check 3: no additional keys in alternative locales"},{"location":"parser_checks/#check-4-interpolation-keys-are-present-in-every-translation","text":"If a translation in the DEFAULT_LOCALE has one or more interpolation keys, then those interpolation keys should also be present in the alternative locales. If not, an error similar to the following will be raised: Error: Some translations have mismatching interpolation keys: \u2023 nl: message.welcome should contain \"%{first_name}\" \u2023 nl: base.validations.min_max should contain \"%{min}\" \u2023 nl: base.validations.min_max should contain \"%{max}\" \u2023 fr: message.welcome should contain \"%{first_name}\"","title":"Check 4: interpolation keys are present in every translation"},{"location":"setup/","text":"Setup The bin/rosetta --init command will generate the initial files to get started. 1. An initializer with the following content: # config/rosetta.cr require \"rosetta\" Rosetta :: DEFAULT_LOCALE = :en Rosetta :: AVAILABLE_LOCALES = %i[en] Rosetta :: Backend . load ( \"config/rosetta\" ) 2. config/rosetta/rosetta.en.yml This file contains localiztions required by Rosetta. For every additional locale, you'll need to copy and translate this file. In the future, files for many languages will be included. Please consider contributing your translations. 3. config/locales/example.en.yml An example locale file, which you can modify or delete.","title":"Setup"},{"location":"setup/#setup","text":"The bin/rosetta --init command will generate the initial files to get started.","title":"Setup"},{"location":"setup/#1-an-initializer-with-the-following-content","text":"# config/rosetta.cr require \"rosetta\" Rosetta :: DEFAULT_LOCALE = :en Rosetta :: AVAILABLE_LOCALES = %i[en] Rosetta :: Backend . load ( \"config/rosetta\" )","title":"1. An initializer with the following content:"},{"location":"setup/#2-configrosettarosettaenyml","text":"This file contains localiztions required by Rosetta. For every additional locale, you'll need to copy and translate this file. In the future, files for many languages will be included. Please consider contributing your translations.","title":"2. config/rosetta/rosetta.en.yml"},{"location":"setup/#3-configlocalesexampleenyml","text":"An example locale file, which you can modify or delete.","title":"3. config/locales/example.en.yml"},{"location":"translations/","text":"Lookup Looking up translations is done with the find macro: Rosetta . find ( \"user.name\" ) This will return a struct containing all the translation data for the given key. To get the translation for the currently selected locale, call the t method: Rosetta . find ( \"user.name\" ) . t # => \"User name\" Optionally, you can call to_s or use the struct with string interpolation: Rosetta . find ( \"user.name\" ) . to_s # => \"User name\" \" #{ Rosetta . find ( \"user.name\" ) } \" # => \"User name\" The translation struct also includes the Lucky::AllowedInTags module, so it works with Lucky templates as well, even without having to call t : class Products:: ShowPage < MainLayout def content h1 Rosetta . find ( \".heading\" ) end end Getting all translations When required, the translations for all locales can be accessed with the translations property: Rosetta . find ( \"user.first_name\" ) . translations # => {en: \"First name\", nl: \"Voornaam\"} Forcing a different locale If a different locale needs to be used in a specific place, use the with_locale method: Rosetta . with_locale ( :nl ) do Rosetta . find ( \"user.first_name\" ) . t # => \"Voornaam\" end The Translatable mixin This mixin makes it more convenient to work with translated values in your classes. Here's an example of its usage: Rosetta . locale = :es class User include Rosetta :: Translatable def name_label r ( \"user.name_label\" ) . t end end User . new . name_label # => \"Nombre\" The r macro essentially is an alias for the Rosetta.find macro, but it introduces the possibility to use inferred locale keys. By omitting the prefix of the locale key and having the key start with a . , the key prefix will be derived from the current class name: class User include Rosetta :: Translatable def name_label r ( \".name_label\" ) . t # => resolves to \"user.name_label\" end end This also works with nested class names, for example: User => \"user\" Components::MainMenu => \"components.main_menu\" Helpers::SiteSections::UserSettings => \"helpers.site_sections.user_settings\" Using inferred locale keys has an added bonus. You don't need to think about how to organise your locale files. And it also makes finding your keys a lot easier. Finally, in case you want to use another prefix for the current class, a constant can be used: class User include Rosetta :: Translatable ROSETTA_PREFIX = \"guest\" def name_label r ( \".name_label\" ) . t # => resolves to \"guest.name_label\" end end Just like the global Rosetta.find marco, interpolations are passed using the t method: class User include Rosetta :: Translatable def welcome_message r ( \".welcome_message\" ) . t ( name : \"Ary\" ) end end The r macro uses Rosetta.find to get the translations for a given key at compile-time. Then the t method translates the value at runtime.","title":"Translations"},{"location":"translations/#lookup","text":"Looking up translations is done with the find macro: Rosetta . find ( \"user.name\" ) This will return a struct containing all the translation data for the given key. To get the translation for the currently selected locale, call the t method: Rosetta . find ( \"user.name\" ) . t # => \"User name\" Optionally, you can call to_s or use the struct with string interpolation: Rosetta . find ( \"user.name\" ) . to_s # => \"User name\" \" #{ Rosetta . find ( \"user.name\" ) } \" # => \"User name\" The translation struct also includes the Lucky::AllowedInTags module, so it works with Lucky templates as well, even without having to call t : class Products:: ShowPage < MainLayout def content h1 Rosetta . find ( \".heading\" ) end end","title":"Lookup"},{"location":"translations/#getting-all-translations","text":"When required, the translations for all locales can be accessed with the translations property: Rosetta . find ( \"user.first_name\" ) . translations # => {en: \"First name\", nl: \"Voornaam\"}","title":"Getting all translations"},{"location":"translations/#forcing-a-different-locale","text":"If a different locale needs to be used in a specific place, use the with_locale method: Rosetta . with_locale ( :nl ) do Rosetta . find ( \"user.first_name\" ) . t # => \"Voornaam\" end","title":"Forcing a different locale"},{"location":"translations/#the-translatable-mixin","text":"This mixin makes it more convenient to work with translated values in your classes. Here's an example of its usage: Rosetta . locale = :es class User include Rosetta :: Translatable def name_label r ( \"user.name_label\" ) . t end end User . new . name_label # => \"Nombre\" The r macro essentially is an alias for the Rosetta.find macro, but it introduces the possibility to use inferred locale keys. By omitting the prefix of the locale key and having the key start with a . , the key prefix will be derived from the current class name: class User include Rosetta :: Translatable def name_label r ( \".name_label\" ) . t # => resolves to \"user.name_label\" end end This also works with nested class names, for example: User => \"user\" Components::MainMenu => \"components.main_menu\" Helpers::SiteSections::UserSettings => \"helpers.site_sections.user_settings\" Using inferred locale keys has an added bonus. You don't need to think about how to organise your locale files. And it also makes finding your keys a lot easier. Finally, in case you want to use another prefix for the current class, a constant can be used: class User include Rosetta :: Translatable ROSETTA_PREFIX = \"guest\" def name_label r ( \".name_label\" ) . t # => resolves to \"guest.name_label\" end end Just like the global Rosetta.find marco, interpolations are passed using the t method: class User include Rosetta :: Translatable def welcome_message r ( \".welcome_message\" ) . t ( name : \"Ary\" ) end end The r macro uses Rosetta.find to get the translations for a given key at compile-time. Then the t method translates the value at runtime.","title":"The Translatable mixin"},{"location":"why_rosetta/","text":"Why use Rosetta? You'll never have a missing translation Rosetta is different from other internationalization libraries because it handles key lookup at compile-time rather than runtime. The significant advantage is that you'll be able to find missing translations - or typos in your locale keys - during development rather than after you've deployed your app. This is also true for translation keys in all additional locales. You'll never have a missing interpolation In Rosetta, interpolation keys are arguments to the translation method. So if you're missing an argument, the compiler will complain. The parser will also compare interpolation keys in additional locales to the ones found in the default locale, and let you know if some are missing. Rosetta is 10x faster than similar libraries Benchmarking against other libraries which also use YAML or JSON files for locales, Rosetta is about 10x faster than any other one. For simple translations: i18n.cr translation 147.72k ( 6.77\u00b5s) (\u00b1 3.36%) 0.99kB/op 178.77\u00d7 slower i18n translation 2.25M (443.68ns) (\u00b1 3.44%) 48.0B/op 11.05\u00d7 slower lens translation 1.10M (912.67ns) (\u00b1 7.10%) 176B/op 22.72\u00d7 slower rosetta translation 24.89M ( 40.17ns) (\u00b1 6.59%) 0.0B/op fastest For translations with interpolations: i18n.cr interpolation 145.50k ( 6.87\u00b5s) (\u00b1 4.47%) 0.99kB/op 23.12\u00d7 slower i18n interpolation 138.84k ( 7.20\u00b5s) (\u00b1 4.16%) 2.05kB/op 21.23\u00d7 slower lens interpolation 314.68k ( 3.18\u00b5s) (\u00b1 7.30%) 561B/op 9.29\u00d7 slower rosetta interpolation 2.95M (339.26ns) (\u00b1 7.17%) 80.0B/op fastest Rosetta is that much faster because a lot of the hard work happens at compile-time. And because the majority of the data is stored on the stack rather than the heap , out of the scope of garbage collector.","title":"Why Rosetta?"},{"location":"why_rosetta/#why-use-rosetta","text":"","title":"Why use Rosetta?"},{"location":"why_rosetta/#youll-never-have-a-missing-translation","text":"Rosetta is different from other internationalization libraries because it handles key lookup at compile-time rather than runtime. The significant advantage is that you'll be able to find missing translations - or typos in your locale keys - during development rather than after you've deployed your app. This is also true for translation keys in all additional locales.","title":"You'll never have a missing translation"},{"location":"why_rosetta/#youll-never-have-a-missing-interpolation","text":"In Rosetta, interpolation keys are arguments to the translation method. So if you're missing an argument, the compiler will complain. The parser will also compare interpolation keys in additional locales to the ones found in the default locale, and let you know if some are missing.","title":"You'll never have a missing interpolation"},{"location":"why_rosetta/#rosetta-is-10x-faster-than-similar-libraries","text":"Benchmarking against other libraries which also use YAML or JSON files for locales, Rosetta is about 10x faster than any other one. For simple translations: i18n.cr translation 147.72k ( 6.77\u00b5s) (\u00b1 3.36%) 0.99kB/op 178.77\u00d7 slower i18n translation 2.25M (443.68ns) (\u00b1 3.44%) 48.0B/op 11.05\u00d7 slower lens translation 1.10M (912.67ns) (\u00b1 7.10%) 176B/op 22.72\u00d7 slower rosetta translation 24.89M ( 40.17ns) (\u00b1 6.59%) 0.0B/op fastest For translations with interpolations: i18n.cr interpolation 145.50k ( 6.87\u00b5s) (\u00b1 4.47%) 0.99kB/op 23.12\u00d7 slower i18n interpolation 138.84k ( 7.20\u00b5s) (\u00b1 4.16%) 2.05kB/op 21.23\u00d7 slower lens interpolation 314.68k ( 3.18\u00b5s) (\u00b1 7.30%) 561B/op 9.29\u00d7 slower rosetta interpolation 2.95M (339.26ns) (\u00b1 7.17%) 80.0B/op fastest Rosetta is that much faster because a lot of the hard work happens at compile-time. And because the majority of the data is stored on the stack rather than the heap , out of the scope of garbage collector.","title":"Rosetta is 10x faster than similar libraries"}]}